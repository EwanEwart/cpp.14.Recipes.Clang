/*
  Unnamed function objects
  Using a Lambda to print array values.
*/
#include <iostream>
#include <array>
#include <algorithm> // for_each

#include <cstdint>

#include "../../../demangle.h"

using std::array ;
using std::cout ;
using std::endl ;
using std::for_each ;

int main ()
{
  using XArray = array<uint32_t, 5> ; // alias

  XArray xArray { { 2, 3, 5, 7, 11 } } ;

  for_each
  (
      xArray.cbegin ()
    , xArray.cend ()
  #if 200400L < __cplusplus && __cplusplus < 201200L
    ,	[] ( XArray::value_type const & number )
  #else
    ,  [] ( auto&& number ) // since c++11
  #endif
    {
      cout << number << ", " ; // since c++14
    }
  ) ;

  cout << '\n' ;


  /* the c++11 lambda
  To have a mixture of "passing by value" and "passing by reference",
  one can declare the lambda as "mutable".
  => In that case, "objects are passed by value",
  but inside the "function-object" or "functor" or "closure" defined by the lambda,
  one has write access to the passed value.
  For example:
  */
  // int id {} ; // id == 0
  int id { 1001 } ; // id == 0
  auto closure = [ id ] () mutable { cout << "id ... " << id << '\n' ; ++id ; } ; // 1) simple by-copy capture; http://en.cppreference.com/w/cpp/language/lambda
  cout << "closure ... " << cxx::demangle ( typeid ( closure ) .name () ) << '\n' ;

  // auto closure = [ id ] () { cout << "id ... " << id << '\n' ; ++id ; } ;
  /*
  error: cannot assign to a variable captured by copy in a non-mutable lambda
  auto closure = [ id ] () { cout << "id ... " << id << '\n' ; ++id ; } ;
  */

  id = 42 ;
  closure () ; // 1001
  closure () ; // 1002
  closure () ; // 1003
  cout << "id ... " << id << '\n' ; // 42

  // The closure generated by the compiler looks something like this ...
  class XClosure
  {
  private:
    int id ;       // copy of outside id;   either NOT mutable
    int const ID ; // copy of outside id;   or mutable
  public:
    XClosure ( int const x ) : id { x }, ID { x } {} // capture list simulation
    void operator () () { cout << "ID ... " << ID << "; id ... " <<  id  <<  '\n' ; ++id ; }
  } ;

  cout << '\n' << "------------------" << '\n' ;

  int Id { 777 } ;
  XClosure xClosure { Id } ; // capture outside state
  Id = 4711 ; // modify outside state
  xClosure () ; // modify inside state
  xClosure () ; // modify inside state
  xClosure () ; // modify inside state
  cout << "Id ... " << Id << '\n' ; // 42

  cout << endl ;

  return 0 ;
}
